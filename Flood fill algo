from collections import deque

def flood_fill_maze(maze, start_row, start_col):
    """
    Performs a flood fill search on a maze to find all reachable cells.

    Args:
        maze (list of list of str): The 2D maze grid.
        start_row (int): The starting row.
        start_col (int): The starting column.

    Returns:
        list of tuples: A list of all coordinates (row, col) that are reachable.
    """
    rows = len(maze)
    cols = len(maze[0])
    
    # Initialize a queue for BFS and a set for visited cells
    q = deque([(start_row, start_col)])
    visited = set([(start_row, start_col)])
    
    # List to store all reachable cells
    reachable_cells = []
    
    # Define the possible directions of movement (up, down, left, right)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    while q:
        r, c = q.popleft()
        reachable_cells.append((r, c))

        # Explore all valid neighbors
        for dr, dc in directions:
            nr, nc = r + dr, c + dc

            # Check if the new position is valid
            if 0 <= nr < rows and 0 <= nc < cols and \
               maze[nr][nc] != '#' and (nr, nc) not in visited:
                
                # Add the new cell to the queue and mark as visited
                visited.add((nr, nc))
                q.append((nr, nc))

    return reachable_cells

# --- Example Usage ---
if __name__ == "__main__":
    # Example maze (0 = path, 1 = wall)
    sample_maze = [
        ['#', '#', '#', '#', '#'],
        ['#', ' ', ' ', ' ', '#'],
        ['#', ' ', '#', ' ', '#'],
        ['#', ' ', ' ', ' ', '#'],
        ['#', '#', '#', '#', '#']
    ]

    start_row = 1
    start_col = 1
    
    reachable = flood_fill_maze(sample_maze, start_row, start_col)
    print(f"Starting at ({start_row}, {start_col}), the reachable cells are:")
    print(reachable)

    # Output: Starting at (1, 1), the reachable cells are:
    # [(1, 1), (1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2), (3, 3)]
